import java.io.*;
import java.util.*;

public class DirectCodeGenerator {
    private static Map<String, String> symbolTable = new HashMap<>();
    private static List<String> tokens = new ArrayList<>();
    private static int currentToken = 0;
    private static int tempCounter = 1;
    private static int labelCounter = 1;
    private static List<String> code = new ArrayList<>();

    static class Expression {
        String code;
        String place;

        Expression(String code, String place) {
            this.code = code;
            this.place = place;
        }
    }

    public static void main(String[] args) {
        try {
            loadSymbolTable("Symbol.txt");
            String input = readInputFile("input.txt");
            tokenize(input);

            // Start parsing from PROG rule
            parseProg();

            writeOutput("output.txt");
            printGeneratedCode();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    private static void parseReturnStatement() {
        advance(); // Skip return
        // Expression returnExp = parseExpression();
        StringBuilder returnCode = new StringBuilder();
        // First add any code generated by the expression

        // Then add the return statement with the place
        code.add("RETURN " + returnCode);
        if (getCurrentToken().equals(";")) {
            advance();
        }
    }

    private static void parsePrintStatement() {
        advance(); // Skip return
        // Expression returnExp = parseExpression();
        StringBuilder returnCode = new StringBuilder();
        // First add any code generated by the expression

        // Then add the return statement with the place
        code.add("PRINT " + returnCode);
        if (getCurrentToken().equals(";")) {
            advance();
        }
    }

    private static void parseStatement() {
        String token = getCurrentToken();
        System.out.println("Parsing statement: " + token);

        switch (token) {
            case "if":
                parseIfStatement();
                break;
            case "return":
                parseReturnStatement();
            case "print":
                parsePrintStatement();
                break;
            case "skip":
                code.add("REM DO NOTHING");
                advance();
                if (getCurrentToken().equals(";")) {
                    advance();
                }
                break;
            default:
                if (token.startsWith("V_")) {
                    parseAssignmentOrInput();
                } else {
                    System.out.println("Unexpected token: " + token);
                    advance(); // Skip unknown token
                }
                break;
        }
    }

    private static void parseIfStatement() {
        advance(); // Skip if
        Expression conditionExp = parseExpression();

        // Skip then
        while (!getCurrentToken().equals("then") && !getCurrentToken().equals("EOF")) {
            advance();
        }
        advance();

        String labelTrue = "L" + labelCounter++;
        String labelFalse = "L" + labelCounter++;
        String labelEnd = "L" + labelCounter++;

        StringBuilder ifCode = new StringBuilder();
        // Add any code needed to evaluate the condition
        if (!conditionExp.code.isEmpty()) {
            ifCode.append(conditionExp.code).append("\n");
        }
        ifCode.append("IF ").append(conditionExp.place)
                .append(" GOTO ").append(labelTrue)
                .append(" ELSE GOTO ").append(labelFalse);
        code.add(ifCode.toString());
        code.add(labelTrue + ":");

        // Parse then block
        while (!getCurrentToken().equals("end") && !getCurrentToken().equals("EOF")) {
            parseStatement();
        }
        advance(); // Skip end

        code.add("GOTO " + labelEnd);
        code.add(labelFalse + ":");

        if (getCurrentToken().equals("else")) {
            advance(); // Skip else
            while (!getCurrentToken().equals("end") && !getCurrentToken().equals("EOF")) {
                parseStatement();
            }
            advance(); // Skip end
        }

        code.add(labelEnd + ":");
    }

    private static Expression parseOperatorExpression(String operator) {
        advance(); // Skip (
        Expression leftExp = parseExpression();
        advance(); // Skip ,
        Expression rightExp = parseExpression();
        advance(); // Skip )

        String temp = "t" + tempCounter++;
        String operatorSymbol = translateOperator(operator);

        StringBuilder codeBuilder = new StringBuilder();
        if (!leftExp.code.isEmpty()) {
            codeBuilder.append(leftExp.code).append("\n");
        }
        if (!rightExp.code.isEmpty()) {
            codeBuilder.append(rightExp.code).append("\n");
        }
        codeBuilder.append(temp).append(" = ")
                .append(leftExp.place).append(" ")
                .append(operatorSymbol).append(" ")
                .append(rightExp.place);

        return new Expression(codeBuilder.toString(), temp);
    }

    private static void printGeneratedCode() {
        System.out.println("\nGenerated Code:");
        for (String line : code) {
            // Split the code into lines and print each line separately
            for (String subline : line.split("\n")) {
                if (!subline.trim().isEmpty()) {
                    System.out.println(subline.trim());
                }
            }
        }
    }

    private static void writeOutput(String filename) throws IOException {
        try (BufferedWriter writer = new BufferedWriter(new FileWriter(filename))) {
            for (String line : code) {
                // Split the code into lines and write each line separately
                for (String subline : line.split("\n")) {
                    if (!subline.trim().isEmpty()) {
                        writer.write(subline.trim());
                        writer.newLine();
                    }
                }
            }
        }
    }

    private static Expression parseExpression() {
        String token = getCurrentToken();
        System.out.println("Parsing expression: " + token);
        advance();

        if (isOperator(token)) {
            System.out.println("DEBUG: parseExpression - found operator: " + token);
            if (token.equals("grt") || token.equals("eq") || token.equals("and") || token.equals("or")) {
                return parseBinaryOp(); // Keep existing comparison operator handling
            } else {
                // For arithmetic operators (add, sub, mul, div)
                if (getCurrentToken().equals("(")) {
                    advance(); // Skip (
                    String place1 = "t" + tempCounter++;
                    Expression exp1 = parseExpression();
                    advance(); // Skip ,
                    String place2 = "t" + tempCounter++;
                    Expression exp2 = parseExpression();
                    advance(); // Skip )

                    String place = "t" + tempCounter++;
                    String opSymbol = translateOperator(token);

                    StringBuilder codeBuilder = new StringBuilder();
                    codeBuilder.append(place1).append(" = ").append(exp1.place).append("\n");
                    codeBuilder.append(place2).append(" = ").append(exp2.place).append("\n");
                    codeBuilder.append(place).append(" = ").append(place1)
                            .append(" ").append(opSymbol).append(" ")
                            .append(place2);

                    System.out
                            .println("DEBUG: parseExpression - arithmetic operation code:\n" + codeBuilder.toString());
                    return new Expression(codeBuilder.toString(), place);
                }
            }
        } else if (token.startsWith("V_") || token.startsWith("F_")) {
            return new Expression("", translateVar(token));
        } else {
            return new Expression("", token); // Constants are translated to themselves
        }
        return new Expression("", "");
    }

    private static String translateOperator(String op) {
        return switch (op) {
            case "add" -> "+";
            case "sub" -> "-";
            case "mul" -> "*";
            case "div" -> "/";
            case "and" -> "AND";
            case "or" -> "OR";
            case "eq" -> "=";
            case "grt" -> ">";
            case "not" -> "NOT";
            case "sqrt" -> "SQR";
            default -> op;
        };
    }

    private static String translateVar(String varName) {
        return symbolTable.getOrDefault(varName.trim(), varName.trim());
    }

    private static boolean isOperator(String token) {
        return token.equals("and") || token.equals("or") || token.equals("eq") ||
                token.equals("grt") || token.equals("add") || token.equals("sub") ||
                token.equals("mul") || token.equals("div") || token.equals("not") ||
                token.equals("sqrt");
    }

    private static boolean isEOF() {
        return currentToken >= tokens.size();
    }

    private static String parseFunctions() {
        StringBuilder functionCode = new StringBuilder();
        while (!isEOF()) {
            String token = getCurrentToken();
            if (token.startsWith("F_")) {
                functionCode.append(parseFunction());
            }
            advance();
        }
        return functionCode.toString();
    }

    private static String parseFunction() {
        StringBuilder funcCode = new StringBuilder();
        String funcName = translateVar(getCurrentToken());
        advance(); // Skip function name

        // Skip parameters and type declarations until begin
        while (!getCurrentToken().equals("begin") && !isEOF()) {
            advance();
        }

        if (getCurrentToken().equals("begin")) {
            advance();
            funcCode.append("FUNCTION ").append(funcName).append("\n");
            funcCode.append(parseAlgo());
            funcCode.append("END FUNCTION\n");
        }

        return funcCode.toString();
    }

    private static String parseCommand() {
        String token = getCurrentToken();
        switch (token) {
            case "skip":
                advance();
                return "REM DO NOTHING\n";
            case "halt":
                advance();
                return "STOP\n";
            case "if":
                return parseBranch();
            case "return":
                advance();
                Expression returnExp = parseExpression();
                return (returnExp.code.isEmpty() ? "" : returnExp.code + "\n") +
                        "RETURN " + returnExp.place + "\n";
            case "print":
                advance();
                Expression returnExps = parseExpression();
                return (returnExps.code.isEmpty() ? "" : returnExps.code + "\n") +
                        "PRINT " + returnExps.place + "\n";
            default:
                if (token.startsWith("V_")) {
                    return parseAssign();
                } else if (token.startsWith("F_")) {
                    return parseCall();
                }
                advance();
                return "";
        }
    }

    private static String parseAssign() {
        String varName = translateVar(getCurrentToken());
        advance();
        String token = getCurrentToken();

        if (token.equals("<")) {
            advance(); // Skip
            advance(); // Skip input
            return "INPUT " + varName + "\n";
        } else if (token.equals("=")) {
            advance();
            Expression exp = parseExpression();
            StringBuilder assignCode = new StringBuilder();

            // Add the arithmetic operation code if it exists
            if (!exp.code.isEmpty()) {
                assignCode.append(exp.code).append("\n");
            }

            // Add the assignment
            assignCode.append(varName).append(" = ").append(exp.place).append("\n");

            return assignCode.toString();
        }

        return "";
    }

    private static Expression parseCondition() {
        if (getCurrentToken().equals("not")) {
            return parseUnaryOp();
        } else if (isBinaryOp(getCurrentToken())) {
            return parseBinaryOp();
        }
        return parseExpression();
    }

    private static String parseBranch() {
        advance(); // Skip if
        Expression cond = parseCondition();
        String labelTrue = "L" + labelCounter++;
        String labelFalse = "L" + labelCounter++;
        String labelEnd = "L" + labelCounter++;

        StringBuilder branchCode = new StringBuilder();

        // First add condition evaluation code if any
        if (!cond.code.isEmpty()) {
            branchCode.append(cond.code).append("\n");
        }

        // Add the if condition and goto statements
        branchCode.append("IF ").append(cond.place)
                .append(" GOTO ").append(labelTrue)
                .append(" ELSE GOTO ").append(labelFalse)
                .append("\n");

        // Add true branch label and code
        branchCode.append(labelTrue).append(":\n");
        advance(); // Skip then
        if (getCurrentToken().equals("begin")) {
            advance(); // Skip begin
            while (!getCurrentToken().equals("end") && !getCurrentToken().equals("EOF")) {
                branchCode.append(parseCommand());
            }
            advance(); // Skip end
        }

        // Add goto to skip else part
        branchCode.append("GOTO ").append(labelEnd).append("\n");

        // Add false branch label and code
        branchCode.append(labelFalse).append(":\n");
        if (getCurrentToken().equals("else")) {
            advance(); // Skip else
            if (getCurrentToken().equals("begin")) {
                advance(); // Skip begin
                while (!getCurrentToken().equals("end") && !getCurrentToken().equals("EOF")) {
                    branchCode.append(parseCommand());
                }
                advance(); // Skip end
            }
        }

        // Add end label
        branchCode.append(labelEnd).append(":\n");

        return branchCode.toString();
    }

    // Update tokenize method to handle all tokens properly
    private static void tokenize(String input) {
        String processed = input.replaceAll("([(){},;])", " $1 ")
                .replaceAll("<", " < ")
                .replaceAll("=", " = ")
                .replaceAll("\"([^\"]*)\"", " \"$1\" ")
                .replaceAll("\n", " ")
                .trim();

        tokens = new ArrayList<>();
        for (String token : processed.split("\\s+")) {
            if (!token.isEmpty()) {
                tokens.add(token);
                System.out.println("Added token: " + token);
            }
        }
    }

    private static String getCurrentToken() {
        return currentToken < tokens.size() ? tokens.get(currentToken) : "EOF";
    }

    private static void advance() {
        if (currentToken < tokens.size()) {
            currentToken++;
        }
    }

    private static void parseProg() {
        // Skip 'main' and variable declarations until 'begin'
        while (!getCurrentToken().equals("begin") && !isEOF()) {
            advance();
        }

        if (getCurrentToken().equals("begin")) {
            advance();
            String algoCode = parseAlgo();
            String functionCode = parseFunctions();
            code.add(algoCode);
            code.add("STOP");
            if (!functionCode.isEmpty()) {
                code.add(functionCode);
            }
        }
    }

    private static String parseAlgo() {
        StringBuilder algoCode = new StringBuilder();
        while (!getCurrentToken().equals("end") && !isEOF()) {
            algoCode.append(parseInstruc());
        }
        advance(); // Skip 'end'
        return algoCode.toString();
    }

    private static String parseInstruc() {
        String commandCode = parseCommand();
        if (getCurrentToken().equals(";")) {
            advance();
            String instrucCode = parseInstruc();
            return commandCode + instrucCode;
        }
        return commandCode;
    }

    private static Expression parseUnaryOp() {
        String op = getCurrentToken();
        advance(); // Skip operator
        advance(); // Skip (
        Expression arg = parseExpression();
        advance(); // Skip )

        String place = "t" + tempCounter++;
        String opCode = op.equals("sqrt") ? "SQR" : op;

        return new Expression(
                arg.code + place + " := " + opCode + "(" + arg.place + ")\n",
                place);
    }

    private static Expression parseBinaryOp() {
        String op = getCurrentToken();
        System.out.println("DEBUG: parseBinaryOp - operator: " + op);
        advance(); // Skip operator
        advance(); // Skip (

        // Handle first expression
        String place1 = "t" + tempCounter++;
        Expression exp1 = parseExpression();
        System.out.println("DEBUG: parseBinaryOp - first exp code: " + exp1.code);
        System.out.println("DEBUG: parseBinaryOp - first exp place: " + exp1.place);

        advance(); // Skip ,

        // Handle second expression
        String place2 = "t" + tempCounter++;
        Expression exp2 = parseExpression();
        System.out.println("DEBUG: parseBinaryOp - second exp code: " + exp2.code);
        System.out.println("DEBUG: parseBinaryOp - second exp place: " + exp2.place);

        advance(); // Skip )

        // Final result place
        String place = "t" + tempCounter++;
        String opSymbol = translateOperator(op);

        StringBuilder codeBuilder = new StringBuilder();
        codeBuilder.append(place1).append(" = ").append(exp1.place).append("\n");
        codeBuilder.append(place2).append(" = ").append(exp2.place).append("\n");
        codeBuilder.append(place).append(" = ").append(place1)
                .append(" ").append(opSymbol).append(" ")
                .append(place2);

        String finalCode = codeBuilder.toString();
        System.out.println("DEBUG: parseBinaryOp - generated code:\n" + finalCode);
        System.out.println("DEBUG: parseBinaryOp - place: " + place);

        return new Expression(finalCode, place);
    }

    private static void parseAssignmentOrInput() {
        String varName = translateVar(getCurrentToken());
        advance();
        String nextToken = getCurrentToken();
        System.out.println("Processing assignment: " + varName + " " + nextToken);

        if (nextToken.equals("<")) {
            advance(); // Skip
            advance(); // Skip input
            code.add("INPUT " + varName);
            if (getCurrentToken().equals(";")) {
                advance();
            }
        } else if (nextToken.equals("=")) {
            advance(); // Skip =
            System.out.println("Parsing right side expression");
            Expression rightSideExp = parseExpression();

            // Add arithmetic operation code before the assignment
            if (!rightSideExp.code.isEmpty()) {
                String[] lines = rightSideExp.code.split("\n");
                for (String line : lines) {
                    if (!line.trim().isEmpty()) {
                        code.add(line.trim()); // This adds the t1 = 2, t2 = 4, t3 = t1 + t2
                    }
                }
            }

            // Now add the assignment
            code.add(varName + " = " + rightSideExp.place);

            if (getCurrentToken().equals(";")) {
                advance();
            }
        }
    }

    private static String parseCall() {
        String fnName = translateVar(getCurrentToken());
        advance(); // Skip function name
        advance(); // Skip (

        List<String> params = new ArrayList<>();
        while (!getCurrentToken().equals(")")) {
            if (getCurrentToken().equals(",")) {
                advance();
                continue;
            }
            Expression param = parseExpression();
            params.add(param.place);
        }
        advance(); // Skip )

        return "CALL_" + fnName + "(" + String.join(",", params) + ")\n";
    }

    // Helper methods
    private static boolean isUnaryOp(String token) {
        return token.equals("not") || token.equals("sqrt");
    }

    private static boolean isBinaryOp(String token) {
        return token.equals("and") || token.equals("or") || token.equals("eq") ||
                token.equals("grt") || token.equals("add") || token.equals("sub") ||
                token.equals("mul") || token.equals("div");
    }

    private static void loadSymbolTable(String filename) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader(filename));
        String line;
        while ((line = reader.readLine()) != null) {
            String[] parts = line.split(":");
            if (parts.length >= 2) {
                symbolTable.put(parts[0].trim(), parts[1].trim());
                System.out.println("Loaded symbol: " + parts[0].trim() + " -> " + parts[1].trim());
            }
        }
        reader.close();
    }

    private static String readInputFile(String filename) throws IOException {
        BufferedReader reader = new BufferedReader(new FileReader(filename));
        StringBuilder sb = new StringBuilder();
        String line;
        while ((line = reader.readLine()) != null) {
            sb.append(line).append("\n");
        }
        reader.close();
        return sb.toString();
    }

    private static void generateCode() {
        // Skip until main
        while (!getCurrentToken().equals("main") && !getCurrentToken().equals("EOF")) {
            advance();
        }

        if (getCurrentToken().equals("EOF")) {
            System.out.println("Error: Reached end of file without finding main");
            return;
        }

        // Skip main
        advance();

        // Skip variable declarations until begin
        while (!getCurrentToken().equals("begin") && !getCurrentToken().equals("EOF")) {
            advance();
        }

        if (getCurrentToken().equals("EOF")) {
            System.out.println("Error: Reached end of file without finding begin");
            return;
        }

        // Skip begin
        advance();

        // Process statements until end
        while (!getCurrentToken().equals("end") && !getCurrentToken().equals("EOF")) {
            System.out.println("Processing statement starting with: " + getCurrentToken());
            parseStatement();
        }

        code.add("STOP");
    }
}
